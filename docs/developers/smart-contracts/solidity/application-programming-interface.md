# Application Programming Interface (API)

### Deploy contract operation

Для примера будем использовать следующий простой контракт:
```solidity
contract C {
    function foo() public pure returns (string)  {
        return "Hello, Echo";
    }
}
```

Предполагается, что на аккаунте кошелька есть деньги.
Создаем контракт:
```
create_contract nathan "608060405234801561001057600080fd5b5061013f806100206000396000f300608060405260043610610041576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063c298557814610046575b600080fd5b34801561005257600080fd5b5061005b6100d6565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561009b578082015181840152602081019050610080565b50505050905090810190601f1680156100c85780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b60606040805190810160405280600b81526020017f48656c6c6f2c204543484f0000000000000000000000000000000000000000008152509050905600a165627a7a72305820fc3c8a0ba561c44ac4e7360f35310d7f136c73d1902fb3d0309a4b927e4f45720029" 0 ECHO 1 2000000 "" true true false
```

Сигнатура этого метода выглядит так:  
```
create_contract(
    string registrar_account, string code,
    uint64_t value, string asset_type,
    uint64_t gasPrice, uint64_t gas,
    string supported_asset_id,
    bool broadcast, bool save_wallet,
    bool eth_accuracy
    )
```

- `registrar_account` - аккаунт владельца контракта
- `code` - строка с байт-кодом контракта вместе с аргументами конструктора в hex-виде
- `value` и `asset_type` - количество и тип ассета, передающиеся в транзакции
- `gasPrice` и `gas` - цена и количество газа
- `supported_asset_id` - ограничение при работе с данным контрактом до указанного ассета (по умолчанию ``)
- `broadcast` - флаг, отвечающий за распространение транзакции по сети (по умолчанию `false`)
- `save_wallet` - флаг, отвечающий за сохранение транзакции в кошельке (по умолчанию `true`)
- `eth_accuracy` - флаг, при установке которого точность при работе с контрактом устанавливается равной точности `Ethereum` (по умолчанию `false`)

После вызова функции, можно подтвердить, что контракт создался с помощью Echo Explorer.



### WebSocket API

Нода Echo предоставляет доступ к своим API через WebSocket. Чтобы включить прослушивание WebSocket на ноде, необходимо запустить её с параметром `rpc-endpoint`, указывая в нём адрес который будет прослушиваться, к примеру `./echo_node --rpc-endpoint 127.0.0.1:8090` запустит ноду, которая станет прослушивать порт 8090.

Взаимодействие с методами API через WebSocket происходят с помощью протокола `JSON-RPC`.

### Call smart contracts

Вызов функций контракта происходит через `call_contract`, который получает следующие аргументы:

- Имя аккаунта владельца
- ID контракта
- HEX-код функции для вызова
- Средства, передаваемые при вызове
- Цена на gas
- Gas, передаваемый при вызове
- Нужно ли распространять транзакцию по сети (по умолчанию `false`)
- Нужно ли сохранять транзакцию в кошельке (по умолчанию `true`)

Пример вызова созданного ранее контракта:

```
call_contract nathan 1.16.0 "c2985578" 0 ECHO 1 2000000 true true
```

### Get result of deployment or call

Для получения результатов выполнения контрактов используется функция `get_contract_result(contract_result_id id)`, принимающая id результатов контрактов, например `1.17.2`.

### Call smart contracts field
Чтобы узнать значение публичного поля контракта, без создания транзакции, достаточно вызвать метод `call_contract_no_changing_state`.

Например `call_contract_no_changing_state 1.16.4 nathan ECHO "73d4a13a"`, где `"73d4a13a"` является хешем имени поля.

### Internal transactions
При трансфере через контракт, значения трансфера записываются в историю переводов, которая хранится на чейне Echo.

Получить список трансферов контракта можно с помощью метода history_api  
`get_contract_history(contract_id_type contract)`.

### Subscribe to Smart Contract Events

Для подписи на события контрактов используется метод database_api  
`subscribe_contract_logs(uint32_t id, contract_id_type contract_id, uint32_t from, uint32_t to)`.

- `id` - произвольный идентификатор, который будет возвращен вместе с событием;
- `contract_id` - идентификатор контракта, на события которого подписываются;
- `from` и `to` - диапазон блоков, в котором прослушиваются события;

Если нужно получать оповещения всегда, то в качестве конечной границы диапазона прослушиваемых блоков можно указать очень большое число, например `2147483647`.

При вызове этого метода, он вернет все уже имеющиеся события в указанном диапазоне так же, как и метод `get_contract_logs`.

Пример подписи на события используя wscat:
```
> {"id":1, "method":"subscribe_contract_logs", "params":[1337,"1.16.0",1,200]}
< {"id":1,"jsonrpc":"2.0","result":[]}

# call contract in echo_wallet

< {"method":"notice","params":[1337,[[{"address":"0100000000000000000000000000000000000000","log":["a887d9f447f44f095186fc4a0bef9914881f330f24d2a2f63242c4c05eb26ee0"],"data":"000000000000000000000000000000000000000000000000000000000000001a"}]]]}
```
