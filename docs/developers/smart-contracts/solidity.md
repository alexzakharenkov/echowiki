# Solidity

Solidity - это объектно-ориентированный язык высокого уровня для реализации "умных контрактов". Полную документацию по нему можно найти [тут](https://solidity.readthedocs.io).

## Intro

Для идентификации аккаунтов и контрактов, в отличии от Ethereum, где используются адреса в виде хешей, в Echo используются инкрементые идентификаторы.

### Важные типы ID

- `1.2.x` - аккаунт
- `1.16.x` - контракт
- `1.17.x` - результат выполнения контракта

### Конвертация идентификаторов Echo в адреса Ethereum

Для того что бы использовать адрес аккаунта или контракта его нужно конвертировать в адрес Ethereum.

Адрес Ethereum представляет собой 20 байт, из которых:
- Первый байт адреса занимает "короткий" тип. Для аккаунта и контракта он заменяется на 00 и 01 соответственно.
- Следующие 11 байт занимают нули.
- Последние 8 байт занимает `uint64_t` число.

Краткая памятка:
```
ff0000000000000000000000ffffffffffffffff  | Conversion of decimal Echo type
[][ 11 bytes of zeros  ][   8 bytes    ]  |       to hex short type:
^ 1 byte id short type    id instance     |   2 -> 00 - account
                                          |  16 -> 01 - contract
1.2.26 = account 26 (0x1a) =              |  dd -> xx - everything else
000000000000000000000000000000000000001a  |
                                          |
1.16.5 = contract 5 =                     |
0100000000000000000000000000000000000005  |

```

## Дополнительные возможности Ethereum при использовании с Echo

Для поддержки различных типов ассетов в контрактах были доработаны как компилятор solidity, так и сама виртуальная машина Ethereum. В следствии чего для использования нового функционала, добавленного в Echo, смарт-контракты требуется компилировать именно с помощью модифицированного компилятора solidity.

### Новые функции в solidity
#### `assetbalance`
Через обращение к адресу, возвращает баланс в указанном ассете.

```
uint assetbalance(string assetId)
```
- `assetId` - string, id ассета(в формате триплета, например "1.3.0").

Пример:
```
contract assetbalance {
    uint public balance;
    function saveBalance(address addr, string assetId) {
        balance = addr.assetbalance(assetId);
    }
}

contract assetbalance2 {
    uint public balance;
    function saveBalance() {
        address addr = 0x0000000000000000000000000000000000000005;
        balance = addr.assetbalance("1.3.1");
    }
}

```

#### `transferasset`
Через обращение к адресу, переводит на него определённую сумму в указанном ассете.

```
void transferasset(uint value, uint assetId)
```
- `value` - uint, сумма перевода.
- `assetId` - uint, ID ассета перевода(в формате uint256).

Пример:
```
contract transferasset {
    function transfer(address addr, uint value, uint assetId) {
        addr.transferasset(value, assetId);
    }
}

contract transferasset2 {
    function transfer() {
        address addr = 0x0000000000000000000000000000000000000003;
        addr.transferasset(100000, 1);
    }
}
```

#### `db.property`
Возвращает значение указанного поля указанного объекта в блокчейне.

```
bytes property(string idAndProperty)
```
- `idAndProperty` - string, id объекта и запрашиваемое поле(например "1.2.5 lifetime_referrer_fee_percentage").

Пример:
```
contract property {
    bytes public data;
    function getProperty(string idAndProperty) {
        data = db.property(idAndProperty);
    }
}

contract property2 {
    bytes public data;
    function getProperty() {
        data = db.property("1.2.5 options.memo_key");
    }
}
```

#### `db.convert`
Конвертирует объект не превышающий 32 байта в uint256.

```
uint convert(bytes data)
```
params:
- `data` - bytes, конвертируемый объект.

Пример:
```
contract convert {
    bytes public data;
    uint public value;
    function getPropertyAndConvert(string idAndProperty) {
        data = db.property(idAndProperty);
        value = db.convert(data);
    }
}
```

#### `msg.idasset`
Возвращает ID ассета с которым была вызвана транзакция создания или вызова контракта в формате uint.

Пример:
```
contract transfer {
    function transfer(address addr, uint value) {
        addr.transferasset(value, msg.idasset);  
    }
}
```

### Flag of supported asset
Поскольку Echo является мультиассетной системой, а Ethereum нет, то это порождает множество проблем, в основе которых лежат такие различия между ассетами как курс, точность, баланс и т.д. Для решения этих проблем был введён параметр `supported_asset_id`, ограничивающий ассеты, с которыми может работать контракт, до одного указанного в параметре.

Данный параметр является опциональным, его можно указать при создании контракта, передав название ассета в качестве параметра `supported_asset_id`.

- Если параметр не установлен, контракт может быть вызван с любым ассетом.
- Если параметр установлен, то вызовы функций контракта могут быть осуществлены исключительно с данным ассетом.

### Flag of using Ethereum accuracy
В Echo в контракты был добавлен флаг отображающий необходимость приведения к Ethereum точности при работе с балансами в контрактах.

- Если флаг не установлен, при работе с балансами используется оригинальная точность ассета контракта.
- Если флаг установлен, при работе с балансами используется Ethereum точность равная 18 знакам после запятой.

По умолчанию данный флаг выставлен в `false`. Флаг можно выставить при создании контракта передав `true` или `false` в качестве параметра `eth_accuracy`.

К примеру, допустим ассет `ECHO` у нас имеет 5 знаков после запятой и если флаг будет установлен в `false` то при отправке 1 ECHO в контракт придёт сумма `100000`, если же флаг будет установлен в `true` при отправке того же 1 ECHO придёт сумма `1000000000000000000`. Флаг был добавлен для возможности полноценной работы контрактов написанных для `Ethereum`.

## Create Smart Contract
Для примера будем использовать следующий простой контракт:
```solidity
contract C {
    function foo() public pure returns (string)  {
        return "Hello, Echo";
    }
}
```

Данный контракт не использует нового функционала, добавленного Echo, поэтому может быть скомпилирован как с помощью стандартного Ethereum toolchain, так и с помощью модифицированного компилятора solc.

### Create with Ethereum toolchain
Пример использования компилятора solidity можно прочитать [тут](https://solidity.readthedocs.io/en/v0.4.24/using-the-compiler.html).

### Create with Echo solc
Воспользуемся компилятором solc чтобы скомпилировать наш контракт:
```
$ solc contract.sol --bin --hashes
Binary:
608060405234801561001057600080fd5b5061013f806100206000396000f300608060405260043610610041576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063c298557814610046575b600080fd5b34801561005257600080fd5b5061005b6100d6565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561009b578082015181840152602081019050610080565b50505050905090810190601f1680156100c85780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b60606040805190810160405280600b81526020017f48656c6c6f2c204543484f0000000000000000000000000000000000000000008152509050905600a165627a7a72305820fc3c8a0ba561c44ac4e7360f35310d7f136c73d1902fb3d0309a4b927e4f45720029
Function signatures:
fc68521a: f(address)
```

### Deploy contract operation
Предполагается, что на аккаунте кошелька есть деньги.
Создаем контракт:
```
create_contract nathan "608060405234801561001057600080fd5b5061013f806100206000396000f300608060405260043610610041576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063c298557814610046575b600080fd5b34801561005257600080fd5b5061005b6100d6565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561009b578082015181840152602081019050610080565b50505050905090810190601f1680156100c85780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b60606040805190810160405280600b81526020017f48656c6c6f2c204543484f0000000000000000000000000000000000000000008152509050905600a165627a7a72305820fc3c8a0ba561c44ac4e7360f35310d7f136c73d1902fb3d0309a4b927e4f45720029" 0 ECHO 1 2000000 "" true true false
```

Сигнатура этого метода выглядит так:  
```
create_contract(
    string registrar_account, string code,
    uint64_t value, string asset_type,
    uint64_t gasPrice, uint64_t gas,
    string supported_asset_id,
    bool broadcast, bool save_wallet,
    bool eth_accuracy
    )
```

- `registrar_account` - аккаунт владельца контракта
- `code` - строка с байт-кодом контракта вместе с аргументами конструктора в hex-виде
- `value` и `asset_type` - количество и тип ассета, передающиеся в транзакции
- `gasPrice` и `gas` - цена и количество газа
- `supported_asset_id` - ограничение при работе с данным контрактом до указанного ассета (по умолчанию ``)
- `broadcast` - флаг, отвечающий за распространение транзакции по сети (по умолчанию `false`)
- `save_wallet` - флаг, отвечающий за сохранение транзакции в кошельке (по умолчанию `true`)
- `eth_accuracy` - флаг, при установке которого точность при работе с контрактом устанавливается равной точности `Ethereum` (по умолчанию `false`)

После вызова функции, можно подтвердить, что контракт создался с помощью Echo Explorer.

## Application Programming Interface (API)

### WebSocket API

Нода Echo предоставляет доступ к своим API через WebSocket. Чтобы включить прослушивание WebSocket на ноде, необходимо запустить её с параметром `rpc-endpoint`, указывая в нём адрес который будет прослушиваться, к примеру `./echo_node --rpc-endpoint 127.0.0.1:8090` запустит ноду, которая станет прослушивать порт 8090.

Взаимодействие с методами API через WebSocket происходят с помощью протокола `JSON-RPC`.

### Call smart contracts

Вызов функций контракта происходит через `call_contract`, который получает следующие аргументы:

- Имя аккаунта владельца
- ID контракта
- HEX-код функции для вызова
- Средства, передаваемые при вызове
- Цена на gas
- Gas, передаваемый при вызове
- Нужно ли распространять транзакцию по сети (по умолчанию `false`)
- Нужно ли сохранять транзакцию в кошельке (по умолчанию `true`)

Пример вызова созданного ранее контракта:

```
call_contract nathan 1.16.0 "c2985578" 0 ECHO 1 2000000 true true
```

### Get result of deployment or call

Для получения результатов выполнения контрактов используется функция `get_contract_result(contract_result_id id)`, принимающая id результатов контрактов, например `1.17.2`.

### Call smart contracts field
Чтобы узнать значение публичного поля контракта, без создания транзакции, достаточно вызвать метод `call_contract_no_changing_state`.

Например `call_contract_no_changing_state 1.16.4 nathan ECHO "73d4a13a"`, где `"73d4a13a"` является хешем имени поля.

### Internal transactions
При трансфере через контракт, значения трансфера записываются в историю переводов, которая хранится на чейне Echo.

Получить список трансферов контракта можно с помощью метода history_api  
`get_contract_history(contract_id_type contract)`.

### Subscribe to Smart Contract Events

Для подписи на события контрактов используется метод database_api  
`subscribe_contract_logs(uint32_t id, contract_id_type contract_id, uint32_t from, uint32_t to)`.

- `id` - произвольный идентификатор, который будет возвращен вместе с событием;
- `contract_id` - идентификатор контракта, на события которого подписываются;
- `from` и `to` - диапазон блоков, в котором прослушиваются события;

Если нужно получать оповещения всегда, то в качестве конечной границы диапазона прослушиваемых блоков можно указать очень большое число, например `2147483647`.

При вызове этого метода, он вернет все уже имеющиеся события в указанном диапазоне так же, как и метод `get_contract_logs`.

Пример подписи на события используя wscat:
```
> {"id":1, "method":"subscribe_contract_logs", "params":[1337,"1.16.0",1,200]}
< {"id":1,"jsonrpc":"2.0","result":[]}

# call contract in echo_wallet

< {"method":"notice","params":[1337,[[{"address":"0100000000000000000000000000000000000000","log":["a887d9f447f44f095186fc4a0bef9914881f330f24d2a2f63242c4c05eb26ee0"],"data":"000000000000000000000000000000000000000000000000000000000000001a"}]]]}
```

## Fees
// TODO

## Hello world!

Создадим простой контракт и сохраним его в файл `piggy.sol`.

Этот контракт принимает деньги при создании и выводит их по единице либо все разом, но при этом удаляя себя.

```
pragma solidity ^0.4.24;

contract PiggyBank {
    address owner;
    
    constructor() public payable {
        owner = msg.sender;
    }
    
    function greet() public pure returns (string) {
        return "Hello World!!!";
    }

    function getPennie() public {
        owner.transfer(1);
        emit pennieReturned();
    }

    function breakPiggy() public {
        selfdestruct(owner);
    }

    event pennieReturned();
}
```

Воспользуемся solc чтобы скомпилировать его и вывести получившийся байткод и хэши функций:

```bash
$ ./solc --bin --hashes piggy.sol

======= piggy.sol:PiggyBank =======
Binary: 
6080604052336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550610254806100536000396000f300608060405260043610610057576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680630314c1bf1461005c5780639e19b52d14610073578063cfae32171461008a575b600080fd5b34801561006857600080fd5b5061007161011a565b005b34801561007f57600080fd5b50610088610154565b005b34801561009657600080fd5b5061009f6101eb565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100df5780820151818401526020810190506100c4565b50505050905090810190601f16801561010c5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16ff5b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166108fc60019081150290604051600060405180830381858888f193505050501580156101bc573d6000803e3d6000fd5b507fbfed43b35c99a41ee9b8cb5a2afa74e45703b17dfd398a3b96260bdebca807cf60405160405180910390a1565b60606040805190810160405280600e81526020017f48656c6c6f20576f726c642121210000000000000000000000000000000000008152509050905600a165627a7a723058202c417e9b0840ebe18e2be5b31caac4edba9cd957395ce053180c3aa9efdd78130029
Function signatures: 
0314c1bf: breakPiggy()
9e19b52d: getPennie()
cfae3217: greet()
```

Создаем контракт от имени nathan с помощью команды `create_contract`, подробности можно узнать в разделе Deploy contract operation.

При создании контракта мы отправляем ему 10000 ECHO
```
create_contract nathan "6080604052336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550610254806100536000396000f300608060405260043610610057576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680630314c1bf1461005c5780639e19b52d14610073578063cfae32171461008a575b600080fd5b34801561006857600080fd5b5061007161011a565b005b34801561007f57600080fd5b50610088610154565b005b34801561009657600080fd5b5061009f6101eb565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100df5780820151818401526020810190506100c4565b50505050905090810190601f16801561010c5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16ff5b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166108fc60019081150290604051600060405180830381858888f193505050501580156101bc573d6000803e3d6000fd5b507fbfed43b35c99a41ee9b8cb5a2afa74e45703b17dfd398a3b96260bdebca807cf60405160405180910390a1565b60606040805190810160405280600e81526020017f48656c6c6f20576f726c642121210000000000000000000000000000000000008152509050905600a165627a7a723058202c417e9b0840ebe18e2be5b31caac4edba9cd957395ce053180c3aa9efdd78130029" 10000 ECHO 1 2000000 "" true true false
```

После добавления получившейся транзакции в чейн, мы можем узнать идентификатор нашего нового контракта.

Для этого нужно получить результат выполнения контракта. Узнать идентификатор результата можно с помощью метода `get_account_history`, запросив последнюю операцию.
```
unlocked >>> get_account_history nathan 1
get_account_history nathan 1
2039-01-01T15:17:26 create_contract_operation nathan fee: 0.00013 ECHO   result: 1.17.0 
```

Результат создания контракта имеет идентификатор `1.17.0`, теперь получаем его с помощью метода `get_contract_result`.
```
unlocked >>> get_contract_result 1.17.0
get_contract_result 1.17.0
[
  0,{
    "exec_res": {
      "excepted": "None",
      "new_address": "0100000000000000000000000000000000000000",
      "output": "608060405260043610610057576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680630314c1bf1461005c5780639e19b52d14610073578063cfae32171461008a575b600080fd5b34801561006857600080fd5b5061007161011a565b005b34801561007f57600080fd5b50610088610154565b005b34801561009657600080fd5b5061009f6101eb565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100df5780820151818401526020810190506100c4565b50505050905090810190601f16801561010c5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16ff5b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166108fc60019081150290604051600060405180830381858888f193505050501580156101bc573d6000803e3d6000fd5b507fbfed43b35c99a41ee9b8cb5a2afa74e45703b17dfd398a3b96260bdebca807cf60405160405180910390a1565b60606040805190810160405280600e81526020017f48656c6c6f20576f726c642121210000000000000000000000000000000000008152509050905600a165627a7a723058202c417e9b0840ebe18e2be5b31caac4edba9cd957395ce053180c3aa9efdd78130029",
      "code_deposit": "Success",
      "gas_refunded": 0,
      "gas_for_deposit": 1885669,
      "deposit_size": 596
    },
    "tr_receipt": {
      "status_code": 1,
      "gas_used": 233531,
      "bloom": "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
      "log": []
    }
  }
]
```

Адрес нового контракта находится в поле `exec_res.new_address`. Он записан в формате адреса Ethereum, в нашем случае это `0100000000000000000000000000000000000000`, что конвертируется в идентификаторы Echo как `1.16.0`.

Теперь, мы можем узнать текущий баланс контракта, а также вызвать его методы.

Узнаем его баланс с помощью метода `list_id_balances`:
```
unlocked >>> list_id_balances 1.16.0
list_id_balances 1.16.0
[{
    "amount": 10000,
    "asset_id": "1.3.0"
  }
]
```

Вызовем метод `greet`, возвращающий константную строку.
```
call_contract nathan 1.16.0 "cfae3217" 0 ECHO 1 2000000 true true
```
Строка, которую вернул контракт, находится в поле результата контракта `exec_res.output` в hex-виде.
```
unlocked >>> get_contract_result 1.17.1
get_contract_result 1.17.1
[
  0,{
    "exec_res": {
      "excepted": "None",
      "new_address": "0000000000000000000000000000000000000000",
      "output": "0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000e48656c6c6f20576f726c64212121000000000000000000000000000000000000",
      "code_deposit": "None",
      "gas_refunded": 0,
      "gas_for_deposit": 0,
      "deposit_size": 0
    },
    "tr_receipt": {
      "status_code": 1,
      "gas_used": 21921,
      "bloom": "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
      "log": []
    }
  }
]

```

Вызовем метод `getPennie`, производящий трансфер на наш аккаунт и создающий ивент.
```
call_contract nathan 1.16.0 "9e19b52d" 0 ECHO 1 2000000 true true
```

Результатом выполнения этого метода баланс контракта должен был уменьшиться на 1, что мы и видим при просмотре его баланса.
```
unlocked >>> list_id_balances 1.16.0
list_id_balances 1.16.0
[{
    "amount": 9999,
    "asset_id": "1.3.0"
  }
]
```

Также в логах резульAта есть запись о событии.
```
"log": [{
    "address": "0100000000000000000000000000000000000000",
    "log": [
    "bfed43b35c99a41ee9b8cb5a2afa74e45703b17dfd398a3b96260bdebca807cf"
    ],
    "data": ""
}
]
```

Вызовем метод `breakPiggy`, возвращающий все деньги контракта обратно нам и уничтожающий сам контракт.
```
call_contract nathan 1.16.0 "0314c1bf" 0 ECHO 1 2000000 true true
```

В результате мы видим, что баланс контракта уменьшился до нуля, а при просмотре объекта контракта отмечено, что он `suicided` и больше вызывать его методы мы не можем.
```
unlocked >>> list_id_balances 1.16.0
list_id_balances 1.16.0
[{
    "amount": 0,
    "asset_id": "1.3.0"
  }
]

unlocked >>> get_object 1.16.0
get_object 1.16.0
[{
    "id": "1.16.0",
    "statistics": "2.20.0",
    "suicided": true,
    "type": "evm"
  }
]
```