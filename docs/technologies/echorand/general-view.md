# Алгоритм EchoRand

Техническое описание генерации блоков в распределенной [blockchain][] проекта **Echo** ([ECHO: A Next Generation Blockhain Platform For Smart Economics][echo-wp]).

За основу для алгоритма **EchoRand** взята теоретическая работа [Algorand v9][algorand-v9], которая описывает приход к консенсусу в децентрализованной сети на основе решения [задачи о византийских генералах][byzantine].

В работе [Algorand v9][algorand-v9] излагается несколько возможных вариантов алгоритма. За основу для **EchoRand** взят вариант под названием **Algorand′2** с некоторыми изменениями.

А именно:

* Изменен способ определения участия конкретного исполнителя в конкретном шаге
* Отказ от модели однократных, производных ключей для подписи сетевых сообщений
* Изменен способ генерации разделяемого случайного состояния на третьем шаге алгоритма BBA

Общая схема работы **EchoRand** описана в работе [ECHO: Model of Functioning of Distributed Ledger][echo-model].

## Общие требования к алгоритму и его реализации

Основные общие требования, вытекающие из [маркетингового описания][echo-wp] **Echo**:

* Максимизация пропускной способности сети по количеству транзакций в секунду
* Минимизация сетевых и вычислительных ресурсов для обеспечения работы сети
* Децентрализация - все решения в сети принимаются консенсусом группы узлов
* Высокая устойчивость к любым злонамеренным действиям в отношении самой сети и её пользователей

Практические требования, условия и цели:

* Максимальная простота исходного кода
* Изолированность исходного кода алгоритма от остального кода проекта **Echo**
* Программное разделение этапов `gc` и `bba`. Это позволит, при необходимости, заменить алгоритм достижения византийского консенсуса.

## Объекты алгоритма

* **Узел сети** - сервер, с работающим процессом `echo_node`, локальной конфигурацией и базой данных. Физическая единица сети, на которой запущен один экземпляр **EchoRand**
* **Локальная конфигурация** - некоторый набор параметров, известный только текущему узлу сети.
* **База (данных)** - [blockchain][] с некоторым набором блоков, возможно "отставший" от состояния в большинстве остальных узлов сети. Хранит актуальные публичные ключи ЭЦП всех участников работы алгоритма.
* **Блок (данных)** - логическая единица базы для хранения набора транзакций и сопутствующих данных, которая может быть проверена на корректность внешними средствами
* **Транзакция** - с точки зрения данного алгоритма, это определенный блок данных, который может быть проверен на корректность внешними средствами
* **Исполнитель** - набор из приватного/публичного ключей [EdDSA][] и баланса в сети **Echo**. Фактически, это пользователь сети **Echo**,
зарегистрированный на конкретном узле сети специальным образом. Один пользователь может быть
зарегистрирован в качестве исполнителя только на одном узле сети в заданный момент времени. На одном узле сети возможна
регистрация нескольких исполнителей.

## Параметры алгоритма

Следующие параметры алгоритма задаются константами, либо настраиваются из конфигурации при запуске **echo_node** и, возможно, корректируются в процессе работы алгоритма в некоторых пределах.

|Обозначение|Описание|
|:---:|---|
| **Λ** | "большой" интервал, среднее время необходимое для распространения сообщения размером 1 мегабайт по сети **Echo** |
| **λ** | "малый" интервал, среднее время необходимое для распространения сообщения размером 256 байт по сети **Echo** |
| **$`N_{g}`$** | количество исполнителей-создателей блоков в раунде, используется в функции **VRF(r, 1)** |
| **$`N_{c}`$** | количество исполнителей-контролёров блоков в раунде, используется в функции **VRF(r, s)**, $`s > 1`$ |
| **$`t_{h}`$** | порог для принятия положительного решения при проверке, может быть выбрано как **$`0.69*N_{c}`$** |
| **μ** | $`4 + 3*k, k > 0`$ - максимум шагов алгоритма, после выполнения которых создается пустой блок |

## Выбор параметров

-

### Выбор интервалов Λ и λ

-

### Выбор количества исполнителей $`N_{g}`$, $`N_{c}`$

-

### Выбор μ - максимального количества шагов алгоритма

-

## Криптографический аппарат

### Алгоритмы

* [EdDSA][] - детерминированный алгоритм создания и проверки электронной цифровой подписи
  *  публичный ключ: 32 байта (256 бит)
  *  приватный ключ: 32 байта (256 бит)
  *  подпись: 64 байта (512 бит)
* [SHA-256][] - алгоритм криптографической хеш-функции
  * хеш: 32 байта (256 бит)
  * функция порядка на множестве хешей (`std::less<hash_t, hash_t>`)
* [VRF][] - проверяемая случайная функция

### Построение VRF

#### Для определения активных исполнителей

Проверяемая случайная функция на каждом раунде **r** и шаге **s** строится итеративно,
следующим образом:
1. **VRF<sub>0</sub>(r, s) = [SHA-256][](Q<sub>r-1</sub>, r, s)**
1. **VRF<sub>n</sub>(r, s) = [SHA-256][](VRF<sub>n-1</sub>(r, s))**

Результатом работы данной функции является массив случайных значений размером **$`N_{g}`$**:

**VRF(r, s) = { VRF<sub>0</sub>(r, s), VRF<sub>1</sub>(r, s), ... }**

Конкретный исполнитель вычисляется из хеша **VRF<sub>i</sub>(r, s)** таким образом, чтобы
вероятность выбора исполнителя активным была пропорциональна его текущему балансу в системе.

Набор **VRFN(r,s)** это массив индексов, различный для каждого узла сети и такой, что
если **i ∈ VRFN(r,s)**, то из **VRF<sub>i</sub>(r, s)** вычисляется идентификатор пользователя
являющийся исполнителем для данного раунда и шага на выбранном узле.

Иными словами, **VRFN** является выборкой тех исполнителей из **VRF**, которые должны выполнятся
на конкретном узле, раунде и шаге.

На разных узлах сети, на одном и том же раунде и шаге алгоритма, множества **VRFN** будут разные,
а множество **VRF** будет одинаковым.

#### Для генерации случайного значения раунда

Начальный вектор **Q(0)** выбирается случайным образом при инициализации [blockchain][] базы.

Далее, вектор **Q<sub>r</sub>** вычисляется следующим образом при создании нового блока:
1. **Q<sub>r</sub>** = **H( signQ<sub>r-1</sub>, r )**, если блок **B(R)** не пуст.
1. **Q<sub>r</sub>** = **H( Q<sub>r-1</sub>, r )**, если блок **B(R)** пуст.

> Подпись в случае **1** использует приватный ключ исполнителя, который создает блок

#### Для генерации случайного значения на r = 7,10,13,... шаге BBA

**BBA_RAND(s) = lsb{ [SHA-256][] { Q<sub>r-1</sub>, r } }**

## Условные обозначения

|Обозначение|Описание|
|:---:|---|
| **N** | количество узлов сети |
| **sign(x)** | подпись [EdDSA][] |
| **H(x)** | хеш [SHA-256][] |
| **r** >= 1 | текущий раунд алгоритма, фактически равно количеству блоков в базе плюс 1 |
| **s** >= 1 | текущий номер шага алгоритма в раунде |
| **B<sub>r</sub>** | блок, созданный на раунде **r**, равен { **r**, **producer-id**, **Q<sub>r</sub>**, **HB<sub>r</sub>**, **HB<sub>r-1</sub>**, **sigB**, **PAY<sub>r</sub>**, **CERT<sub>Br</sub>** } |
| **HB<sub>r</sub>** | хеш блока **B<sub>r</sub>** |
| **PAY<sup>r</sup>** | набор транзакций в блоке **B<sub>r</sub>**  |
| **Q<sub>r</sub>** | разделяемый случайный вектор раунда **r** |
| **signQ<sub>r</sub>** | подпись случайного вектора раунда **r** |
| **signB<sub>r</sub>** | подпись блока раунда **r** |
| **l(r)** | лидер раунда **r** - определяет **PAY<sup>r</sup>**, создает **B<sub>r</sub>** и определяет **Q<sub>r</sub>** |
| **CERT<sub>r</sub>** | сертификат блока **B<sub>r</sub>**, формируется из набора сообщений **bba_signature** |
| **VRF(r, s)** | упорядоченное множество исполнителей, которые участвуют в шаге **s** раунда **r** |
| **VRFN(r, s)** | упорядоченное множество индексов исполнителей из **VRF(r, s)**, которые зарегистрированы на текущем узле и участвуют в шаге **s** раунда **r** |

Под экземпляром алгоритма **EchoRand** понимается реализация алгоритма, которая выполняется на некотором узле сети **Echo**.

## Функция **VRF(r, s)**

Построение данной функции описано в документе [ECHO: Model of Functioning of Distributed Ledger][echo-model],
в виде интервального дерева для всех известных исполнителей в системе.

Функция возвращает список исполнителей заданной длины для раунда **r** и шага **s**, одинаковый для всех узлов сети.

Следует заметить, что функция использует некоторое фиксированое состояние [blockchain][] базы для вычисления
балансов исполнителей. В общем случае эта функция может использовать состояние в раунде **max{0, r - k}**, где **k = 1,...**.

Для вычисления функции требуется случайный вектор раунда **Q(r-k)**.

## Описание алгоритма

Изложение работы алгоритма для раунда **r** и некоторого фиксированного исполнителя.

Любое использование функции **sign(x)** предполагает использование приватного ключа этого фиксированного исполнителя, который доступен для экземпляра алгоритма **EchoRand**.

Публичные ключи всех исполнителей сети **Echo** предполагаются доступными на каждом узле сети.

Изложение механизма регистрации исполнителей на узле, соответствия их учетным записям сети **Echo** и распространению их публичных ключей выходит за рамки данного документа.

### Начало работы

#### 0. Подготовка

**Входные данные**:
* **Q<sub>r-1</sub>** из **CERT<sub>r-1</sub>**

Происходит создание раунда **R<sub>r</sub>**, который запускает шаги 1 и 2, описанные ниже. 

#### 1. Генерация блоков-кандидатов

**Входные данные**:
* **HB<sub>r-1</sub>** из **CERT<sub>r-1</sub>**
* **A<sub>1</sub>**, **N<sub>1</sub>** из контекста раунда

1. **Старт**: сразу после определения **CERT<sub>r-1</sub>**
1. **Проверка**:
    1. если **N<sub>1</sub>=∅**, завершить шаг
    1. выбрать индекс исполнителя с **n = N<sub>1</sub>[0]** в качестве создателя блока данного узла
    1. получить реальный идентификатор исполнителя в [blockchain][]: **id<sub>1</sub> = A<sub>1</sub>[n]**
    1. по **id<sub>1</sub>** исполнителя получить его приватные ключи
1. **Сборка блока**:
  1. если все предыдущие блоки **B(k), k=1..r-1** доступны, то построить **PAY<sup>r</sup>**
  1. если хотя бы один из предыдущих блоков недоступен, то **PAY<sup>r</sup> = ∅**
  1. если **PAY<sup>r</sup> != ∅**, создать новый блок **B<sub>r</sub> = { r, PAY<sup>r</sup>, Q<sub>r-1</sub>, signQ<sub>r-1</sub>, HB<sub>r-1</sub> }**
1. **Коммуникация**: формирование, подпись и одновременная отсылка сообщений:
  1. подписать ключом **id<sub>1</sub>** и отослать **gc_block** = **{ r, id<sub>1</sub>, B<sub>r</sub>, signB<sub>r</sub> }**
  1. подписать ключом **id<sub>1</sub>** и отослать **gc_signature** = **{ r, id<sub>1</sub>, signQ<sub>r-1</sub>, HB<sub>r</sub> }**

### Выработка оценочного соглашения (GC)

#### 2. Выбор лидера (голосование)

**Входные данные**:
* **HB<sub>r-1</sub>**, **Q<sub>r-1</sub>** из **CERT<sub>r-1</sub>**
* **A<sub>1</sub>**, **A<sub>2</sub>**, **N<sub>2</sub>** из контекста раунда

**v** - некоторая локальная структура шага, которая хранит хеш блока и идентификатор лидера, создавшего блок.

Символ пустого множества, присвоенный элементам **v** означает "пустой блок" и "неизвестный лидер".
В приложении это может быть какая-то предпопределенная константа, либо отдельный флаг в структуре данных.

1. **Старт**: сразу после определения **CERT<sub>r-1</sub>**
1. **Таймер**: запланировать таймер через время **2 * λ**, по срабатыванию:
    1. определить **l**, как **id** из полученных сообщений в **ctx[id]** с минимальным индексом в **A<sub>1</sub>**
    1. если в локальном кеше для **l** есть блок **B<sub>r</sub>**
        1. **v = { ctx[l].HB, l }**
        1. перейти к **Коммуникации**
1. **Таймер**: запланировать таймер через время **λ + Λ**, по срабатыванию:
    1. **v = { ∅, ∅ }**
    1. перейти к **Коммуникации**
1. **Сеть**: подписаться на сообщения **gc_block**, **gc_signature** из сети при старте шага
    1. при получении сообщения **gc_block** раунда **r**
        1. проверить номер раунда в сообщении
        1. проверить шаг сообщения равен **1**
        1. проверить, что **msg.id ∈ A<sub>1</sub>** и получить публичный ключ пользователя
        1. проверить подпись всего сообщения
        1. проверить, что **msg.block** корректный
            1. проверить раунд блока на равенство текущему
            1. проверить **producer-id** ∈ A<sub>1</sub>**
            1. проверить **Q<sub>r</sub>** из блока, если уже есть **gc_signature** для этого блока
            1. проверить подпись блока используя **producer-id** блока
            1. проверить **HB<sub>r-1</sub>** из блока на равенство локальному из **CERT<sub>r-1</sub>**
            1. проверить корректность **PAY<sup>r</sup>** в блоке
        1. если **ctx[msg.id]** уже создан
            1. проверить **ctx[msg.id].HB == H(msg.block)**
        1. если не создан, сохранить пару **msg.id, msg.block** в контекст раунда:
            1. **ctx[msg.id].B = msg.block**
            1. **ctx[msg.id].HB = H(msg.block)**
        1. если установлено **l** и **l == id**:
            1. **v = { ctx[l].HB, l }**
            1. перейти к **Коммуникации**
    1. при получении сообщения **gc_signature** раунда **r**
        1. проверить номер раунда в сообщении
        1. проверить, что **msg.id ∈ A<sub>1</sub>** и получить публичный ключ пользователя
        1. проверить подпись всего сообщения
        1. **msg.block_hash = ∅**: проверить **msg.rand** на равенство локальному из **CERT<sub>r-1</sub>**
        1. **msg.block_hash != ∅**: проверить подпись **msg.rand** используя **Q<sub>r-1</sub>** из **CERT<sub>r-1</sub>**
        1. сохранить **msg.id => ∅** в контекст раунда, если еще не сохранен:
            1. **ctx[msg.id].B = ∅**
            1. **ctx[msg.id].HB = msg.block_hash**
            1. **ctx[msg.id].rand = msg.rand**
1. **Коммуникация**: формирование, подпись и отсылка сообщений
    1. остановить таймеры, **не** отписываться от событий сети
    1. если **N<sub>2</sub> = ∅**, завершить шаг
    1. **∀n<sub>2</sub> ∈ N<sub>2</sub>**:
        1. получить реальный идентификатор исполнителя в [blockchain][]: **id<sub>2</sub> = A<sub>2</sub>[n<sub>2</sub>]**
        1. подписать ключом **id<sub>2</sub>** и отослать
            1. если **v != ∅**: **gc_proposal** = **{ r, 2, id<sub>2</sub>, v }**
            1. если **v == ∅**: **gc_proposal** = **{ r, 2, id<sub>2</sub>, ∅ }**

#### 3. Выбор лидера (подсчет голосов)

**Входные данные**: **A<sub>2</sub>**, **A<sub>3</sub>**, **N<sub>3</sub>** из контекста раунда

**Старт**: сразу после определения **CERT<sub>r-1</sub>**

**v** - некоторая локальная структура шага, которая хранит хеш блока и идентификатор лидера, создавшего блок.

1. **Таймер**: запланировать таймер через время **3 * λ + Λ**, по срабатыванию:
    1. **v = { ∅, ∅ }**
    1. перейти к **Коммуникации**

1. **Сеть**: подписаться на сообщения **gc_proposal** из сети при старте шага, при получении
    1. проверить номер раунда и шага в сообщении
    1. проверить, что **msg.id ∈ A<sub>2</sub>** и получить публичный ключ пользователя
    1. проверить подписи в сообщении
    1. проверить, что **msg.v = { msg.block_hash, msg.leader }** содержится в контексте раунда.
    Должно быть собрано в контекст на предыдущем шаге, как результат обработки сообщений **gc_block**, **gc_signature**.
        1. **∃ ctx[msg.leader]** - запись для такого потенциального лидера существует в контексте
        1. **ctx[msg.leader].HB == msg.block_hash** - хеш блока совпадает
    1. **ctx[msg.leader].v3.push(msg.id)**, где **v3** это *unordered_set*
    1. если счетчик больше порога **$`t_{h}`$**: **ctx[msg.leader].v3.size() > $`t_{h}`$**
        1. **v = { msg.block_hash, msg.leader }**
        1. перейти к **Коммуникации**

1. **Коммуникация**: формирование, подпись и отсылка сообщений
    1. остановить таймеры, отписаться от событий сети
    1. если **N<sub>3</sub> = ∅**, завершить шаг
    1. **∀n<sub>3</sub> ∈ N<sub>3</sub>**:
        1. получить реальный идентификатор исполнителя в [blockchain][]: **id<sub>3</sub> = A<sub>3</sub>[n<sub>3</sub>]**
        1. подписать ключом пользователя **id<sub>3</sub>** и отослать **gc_proposal** = **{ r, 3, id<sub>3</sub>, v }**

#### 4. Первичная оценка подсчета голосов

**Старт**: Сразу после окончания шага **3**

**Входные данные**: **A<sub>3</sub>**, **A<sub>4</sub>**, **N<sub>4</sub>** из контекста раунда

1. **Таймер**: запланировать таймер через время **2 * λ**, по срабатыванию:
    1. если **∃l | ctx[l].v4.size() > $`t_{h}/2`$**: **v = { ctx[l].HB, l }**
        1. иначе: **v = { ∅, ∅ }**
    1. **b = 1**
    1. перейти к **Коммуникации**

1. **Сеть**: подписаться на сообщения **gc_proposal** из сети при старте шага, при получении
    1. проверить номер раунда и шага в сообщении
    1. проверить, что **id ∈ A<sub>3</sub>** и получить публичный ключ пользователя
    1. проверить подписи в сообщении
    1. **msg.v = { msg.block_hash, msg.leader }**
    1. **msg.v != { ∅, ∅ }**: проверить, что **msg.v** содержится в контексте раунда (должно быть собрано на шаге 2)
        1. **∃ ctx[msg.leader]** - запись для такого потенциального лидера существует в контексте
        1. **ctx[msg.leader].HB == msg.block_hash** - хеш блока совпадает
        1. **ctx[msg.leader].v4.push(msg.id)**, **v4** это *unordered_set*
        1. если **ctx[msg.leader].v4.size() > $`t_{h}`$**
            1. **v = { msg.block_hash, msg.leader }**, **b = 0**
            1. перейти к **Коммуникации**
    1. **msg.v == { ∅, ∅ }**
        1. **ctx.ve4.push(msg.id)**, **ve4** это *unordered_set* (**v**alue **e**mpty)
        1. если **ctx.ve4.size() > $`t_{h}`$**
            1. **v = { ∅, ∅ }**, **b = 1**
            1. перейти к **Коммуникации**

1. **Коммуникация**: формирование, подпись и отсылка сообщений
    1. остановить таймеры, отписаться от событий сети
    1. если **N<sub>4</sub> = ∅**, завершить шаг
    1. **∀ n<sub>4</sub> ∈ N<sub>4</sub>**:
        1. получить реальный идентификатор исполнителя в [blockchain][]: **id<sub>4</sub> = A<sub>4</sub>[n<sub>4</sub>]**
        1. подписать ключом **id<sub>4</sub>** и отослать **bba_signature** = **{ r, 4, id<sub>4</sub>, b, v, sign(0, v) }**

### Достижение византийского соглашения (BBA)

Существует несколько классов алгоритмов для достижения византийского соглашения. Алгоритм, который
используется в **echorand** основан на использовании разделяемого случайного значения.

Основная идея алгоритма состоит в следующем. На каждом шаге работы алгоритма,
узлы в сети можно разбить на два множества:

1. узлы, которые получили за предыдущие раунд(-ы) достаточное количество сообщений
(с некоторым одинаковым значением), позволяющее им предложить это значение в качестве
решения.

1. узлы, которые получили два варианты решения в сообщениях и не могут отдать
предпочтение какому-либо из них.

В последнем случае, неопределившиеся узлы используют [VRF][] для генерации разделяемого случайного числа
из множества **{ 0, 1 }** для принятия и отсылки своего решения. В силу того, что случайное число будет
одно и то же для всех "неуверенных" узлов, все такие узлы примут одинаковое решение.

Используемые обозначения для хранения данных:
* **bba0** - сообщения с **непустым** блоком и голосом равным **1**
* **bba1** - сообщения с **непустым** блоком и голосом равным **0**
* **bbae0** - сообщения с **пустым** блоком и голосом равным **0**
* **bbae1** - сообщения с **пустым** блоком и голосом равным **1**

#### 5. Первый шаг: монетка == 0

**Шаг**: **$`5 \le s \le μ; \space s - 2 \equiv 0 \bmod 3 \space (s = 5,8,11,...)`$**

**Старт**: Сразу после окончания шага **s ≡ 1 mod 3, s > 3**

**Входные данные**:
* **A<sub>s-1</sub>, N<sub>s-1</sub>, A<sub>s</sub>, N<sub>s</sub>** из контекста раунда
* **HB<sub>r-1</sub>**, **Q<sub>r-1</sub>** из **CERT<sub>r-1</sub>** - для формирования пустого блока

**b** - локальный флаг шага, который отсылается в поле **value** сообщения **bba_signature**.

1. **Таймер**: запланировать таймер через время **2 * λ**, по срабатыванию:
    1. **b = 0**
    1. перейти к **Коммуникации**

1. **Сеть**: подписаться на сообщения **bba_signature** из сети при старте шага, при получении
    1. проверить, что **msg.id ∈ A<sub>s-1</sub>** и получить публичный ключ пользователя
    1. проверить подписи сообщения
    1. **msg.v = { msg.block_hash, msg.leader }**
    1. **msg.v != { ∅, ∅ }**:
        1. **∃ ctx[msg.leader]** - запись для такого потенциального лидера существует в контексте
        1. **ctx[msg.leader].HB == v.HB<sub>r</sub>** - хеш блока совпадает
        1. **msg.value == 0**: **ctx[v.l].bba0[msg.s].push(msg.id, msg)**, где **bba0** массив *unordered_map*
        1. **msg.value == 1**: **ctx[v.l].bba1[msg.s].push(msg.id, msg)**, где **bba1** массив *unordered_map*
    1. **msg.v == { ∅, ∅ }**:
        1. **msg.value == 0**: **ctx.bbae0[msg.s].push(msg.id, msg)**, **bbae0** это массив *unordered_map*
        1. **msg.value == 1**: **ctx.bbae1[msg.s].push(msg.id, msg)**, **bbae1** это массив *unordered_map*
    1. если **∀ s >= 5 && s - 2 ≡ 0 mod 3** (**s == 5,8,11,...**) - **Ending Condition 0**
        1. если **∃l | ctx[l].bba0[s-1].size() > $`t_{h}`$**:
            1. **B<sub>r</sub> = ctx[l].B**
            1. **Q<sub>r</sub>** вычисляется из **ctx[l].signQ**, определенной на шаге 2
            1. **CERT<sub>r</sub>** формируется из **ctx.bba1[s-1], ctx.bbae1[s-1], ctx.bba0[s-1], ctx.bbae0[s-1]**
            1. **b = 0<sup>*</sup>**
            1. **КОНЕЦ РАУНДА!!!**
    1. если **∀ s >= 6 && s - 2 ≡ 1 mod 3** (**s == 6,9,12,...**) - **Ending Condition 1**
        1. если $`\sum_{n}ctx[n].bba1[s-1].size() + ctx.bbae1[s-1].size() > t_{h}`$:
            1. **B<sub>r</sub> = ∅**
            1. **Q<sub>r</sub>** вычисляется из **Q<sub>r-1</sub>**
            1. **CERT<sub>r</sub>** формируется из **ctx.bba1[s-1], ctx.bbae1[s-1], ctx.bba0[s-1], ctx.bbae0[s-1]**
            1. **b = 1<sup>*</sup>**
            1. **КОНЕЦ РАУНДА!!!**
    1. если $`\sum_{n}ctx[n].bba1[s-1].size() + ctx.bbae1[s-1].size() > t_{h}`$: **b = 1** и к **Коммуникации**
    1. если $`\sum_{n}ctx[n].bba0[s-1].size() + ctx.bbae0[s-1].size() > t_{h}`$: **b = 0** и к **Коммуникации**

1. **Коммуникация**: формирование, подпись и отсылка сообщений
    1. остановить таймеры, **не** отписываться от событий сети
    1. остановить проверку последних двух условий предыдущего пункта
    1. если **N<sub>s</sub> = ∅**, завершить шаг
    1. **∀n<sub>s</sub> ∈ N<sub>s</sub>**:
        1. получить реальный идентификатор исполнителя в [blockchain][]: **id<sub>s</sub> = A4[n<sub>s</sub>]**
        1. подписать ключом **id<sub>s</sub>** и отослать **bba_signature** = **{ r, s, id<sub>s</sub>, b, v, sign(b, v) }**
        1. где **v**, значение вычисленное на шаге 4

#### 6. Второй шаг: монетка == 1

**Шаг**: **$`6 \le s \le μ; \space s - 2 \equiv 1 \bmod 3 \space (s = 6,9,12,...)`$**

**Старт**: Сразу после окончания шага **s ≡ 2 mod 3, s > 3**

**Входные данные**:
* **A<sub>s-1</sub>, N<sub>s-1</sub>, A<sub>s</sub>, N<sub>s</sub>** из контекста раунда
* **HB<sub>r-1</sub>**, **Q<sub>r-1</sub>** из **CERT<sub>r-1</sub>** - для формирования пустого блока

**b** - локальный флаг шага, который отсылается в поле **value** сообщения **bba_signature**.

1. **Таймер**: запланировать таймер через время **2 * λ**, по срабатыванию:
    1. **b = 1**
    1. перейти к **Коммуникации**

1. **Сеть**: подписаться на сообщения **bba_signature** из сети при старте шага, при получении
    1. проверить, что **msg.id ∈ A<sub>s-1</sub>** и получить публичный ключ пользователя
    1. проверить подписи сообщения
    1. **msg.v = { msg.block_hash, msg.leader }**
    1. **msg.v != { ∅, ∅ }**: как в шаге **5**
    1. **msg.v == { ∅, ∅ }**: как в шаге **5**
    1. если **∀ s >= 5 && s - 2 ≡ 0 mod 3** (**s == 5,8,11,...**): как в шаге **5** - **Ending Condition 0**
    1. если **∀ s >= 6 && s - 2 ≡ 1 mod 3** (**s == 6,9,12,...**): как в шаге **5** - **Ending Condition 1**
    1. если $`\sum_{n}ctx[n].bba0[s-1].size() > t_{h}`$: **b = 0** и к **Коммуникации**

    > $`\sum_{n}ctx[n].bba1[s-1].size() > t_{h}`$ в этом шаге можно не проверять, как это делается в других
    > шагах. В данном шаге это условие равно условию **Ending Condition 1**.

1. **Коммуникация**: как в шаге **5**

#### 7. Третий шаг: монетка = разделяемое случайное значение

**Шаг**: **$`7 \le s \le μ; \space s - 2 \equiv 2 \bmod 3 \space (s = 7,10,13,...)`$**

**Старт**: Сразу после окончания шага **s ≡ 0 mod 3, s > 3**

**Входные данные**:
* **A<sub>s-1</sub>, N<sub>s-1</sub>, A<sub>s</sub>, N<sub>s</sub>** из контекста раунда
* **HB<sub>r-1</sub>**, **Q<sub>r-1</sub>** из **CERT<sub>r-1</sub>** - для формирования пустого блока

**b** - локальный флаг шага, который отсылается в поле **value** сообщения **bba_signature**.

1. **Таймер**: запланировать таймер через время **2 * λ**, по срабатыванию:
    1. **b = BBA_RAND(r)**
    1. перейти к **Коммуникации**

1. **Сеть**: подписаться на сообщения **bba_signature** из сети при старте шага, при получении
    1. проверить, что **msg.id ∈ A<sub>s-1</sub>** и получить публичный ключ пользователя
    1. проверить подписи сообщения
    1. **msg.v = { msg.block_hash, msg.leader }**
    1. **msg.v != { ∅, ∅ }**: как в шаге **5**
    1. **msg.v == { ∅, ∅ }**: как в шаге **5**
    1. если **∀ s >= 5 && s - 2 ≡ 0 mod 3** (**s == 5,8,11,...**): как в шаге **5** - **Ending Condition 0**
    1. если **∀ s >= 6 && s - 2 ≡ 1 mod 3** (**s == 6,9,12,...**): как в шаге **5** - **Ending Condition 1**
    1. если $`\sum_{n}ctx[n].bba1[s-1].size() + ctx.bbae1[s-1].size() > t_{h}`$: **b = 1** и к **Коммуникации**
    1. если $`\sum_{n}ctx[n].bba0[s-1].size() + ctx.bbae0[s-1].size() > t_{h}`$: **b = 0** и к **Коммуникации**

1. **Коммуникация**: как в шаге **5**

#### Узлы, окончившие раунд

Проблема:
* узел уже окончил раунд
* другие узлы еще исполняют последующие шаги

Если узел, окончивший раунд, на последующих шагах должен отсылать **bba** сообщения с оценкой
(то есть, для него **N<sub>s</sub>** непустое на каких-то последующих шагах), то выбор такого узла,
закончившего раунд, должен каким-то образом попасть ко всем остальным узлам.

Решение: эмуляция шага **bba**

**Входные данные**:
* последнее значение **b**
* выбранный блок в виде **v = { block_hash, leader }**

1. если не было сообщений предыдущего шага от других узлов - завершить шаг и раунд
1. иначе:
    1. регистрировать наличие сообщений от других узлов для текущего раунда/шага
    1. если **N<sub>s</sub> != ∅**, отослать сообщение **bba_signature** со своим выбором

### Получение нового блока всеми участниками сети

Все узлы сети исполняют шаги раунда. Сообщения в сеть отсылают только те узлы, для которых выбраны
исполнители на заданном шаге с помощью алгоритма **VRFN(r,s)**.

Таким образом все узлы сети достигают конца раунда на одном из этапов выполнения алгоритма **BBA**
и получают сформированный **CERT<sub>r</sub>**.

Если значение **ctx[l].B != ∅**, то блок получен.

Если значение **ctx[l].B == ∅**, то:

* **ctx[l].signQ == Q<sub>r-1</sub>** означает, что создан пустой блок.
* **ctx[l].signQ != Q<sub>r-1</sub>** означает, что создан непустой блок и узел его не получил.

## Сетевое взаимодействие

### Формат сообщений

Каждое сообщение целиком подписывается [EdDSA][] ключом исполнителя, который создает сообщение. То есть,
фактически, в сообщении всегда присутствует поле **message_signature**.

Отдельные поля или группы полей подписываются тоже подписывается [EdDSA][] ключом исполнителя, который
создает сообщение.

Такая "двойная" подпись необходима, так как подписи определенных групп полей в дальнейшем используются в
[VRF][] для генерации случайного значения раунда и в наборе подписей **CERT<sub>r</sub>**.

#### 1. gc_block (блок-кандидат)

Данное сообщение отправляется на шаге **1**, в случае создания блока с непустым набором транзакций.

|Поле|Описание|
|---|---|
| **round** | текущий раунд |
| **step** | текущий шаг |
| **id** | идентификатор исполнителя, создавшего блок |
| **signature** | подпись сообщения ключом исполнителя **id** |
| **block** | блок, содержащий в себе: текущий раунд, идентификатор исполнителя, подпись блока и т.д. |

#### 2. gc_signature (подпись случайной величины)

Данное сообщение отправляется на шаге **1**, в случае наличия хотя бы одного исполнителя для узла на этот шаг.

|Поле|Описание|
|---|---|
| **round** | текущий раунд |
| **step** | текущий шаг |
| **id** | идентификатор исполнителя, создавшего блок |
| **signature** | подпись сообщения ключом исполнителя **id** |
| **rand** | **signQ<sub>r</sub>** - подпись случайного вектора предыдущего раунда ключом исполнителя **id** |
| **block_hash** | хеш нового блока |
| **prev_rand** | **signQ<sub>r</sub>** подпись случайного вектора раунда из предыдущего блока |
| **prev_block_hash** | хеш предыдущего блока |

#### 3. gc_proposal (выбор лидера и блока)

Данное сообщение отправляется на шагах **2** и **3**, в случае наличия хотя бы одного исполнителя для узла
на этот шаг.

|Поле|Описание|
|---|---|
| **round** | текущий раунд |
| **step** | текущий шаг |
| **id** | идентификатор исполнителя, создавшего данное сообщение |
| **signature** | подпись сообщения ключом исполнителя **id** |
| **block_hash** | хеш выбранного блока |
| **leader** | идентификатор выбранного лидера, который создал блок |

#### 4. bba_signature (результат работы шага BBA)

Данное сообщение отправляется на шаге **4** и всех последующих шагах алгоритма, в случае наличия хотя бы
одного исполнителя для узла на этот шаг.

|Поле|Описание|
|---|---|
| **round** | текущий раунд |
| **step** | текущий шаг |
| **id** | идентификатор исполнителя, создавшего данное сообщение |
| **value** | оценка в рамках алгоритма **BBA**, 0 или 1 |
| **block_hash** | хеш выбранного блока |
| **leader** | идентификатор выбранного лидера, который создал блок |
| **_bba_sign** | подпись полей **round**, **step**, **value**, **block_hash**, **leader** ключом исполнителя **id** |
| **signature** | подпись полей **value**, **block_hash**, **leader** ключом исполнителя **id** |

### Обработка сообщений

Обработка сообщений сети запущенная на шаге **2** не останавливается при завершении шага, а продолжается
до конца раунда.

Обработка сообщений сети шагов **BBA** (**s = 5,...**) фактически одинаковая и не зависит от номера шага.

Разница в сетевых обработчиках на этих шагах состоит в последующем анализе внутренних счетчиков контекста
раунда. Следовательно сетевая обработка для этих шагов может быть эффективно реализована в базовом классе.

### Распространение сообщений

Первое полученное сообщения **gc_block**, **gc_signature** узел пересылает всегда.

Все последующие сообщения **gc_block**, **gc_signature**, которые узел получит, следует пересылать только
в том случае, если **id** исполнителя в этом сообщении имеет наименьший индекс в массиве **A<sub>step</sub>**,
среди всех полученных сообщений такого класса.

Все остальные сообщения раунда обрабатываются и пересылаются узлом только в случае:

* узел впервые получил данное сообщение
* сообщение проходит все проверки на корректность

## Исключительные ситуации

### Отсутствие сети

Шаги алгоритма не будут получать сообщения и все выходы из шагов будут происходить только по срабатыванию таймера.

Так как **конец раунда** на данный момент происходит только как реакция на приходящее сообщение, то шаги
**BBA** будут выполнятся в цикле до достижения константы **μ**. В результате будет сгенерирован пустой блок.

### Восстановление сети

Узлы, которые в результате восстановления сети войдут в раунд в середине, будут содержать неполные данные
в своих контекстах раунда. В результате они будут генерировать либо *неверные* оценки, либо голосовать
за пустой блок.

В каждом из этих вариантов узлы будут себя вести как узел-злоумышленник. В результате информация с таких
узлов будет отфильтрована алгоритмом **bba**.

В силу неполных данных в локальных контекстах такие узлы завершат раунд:
* с неверным блоком
* с пустым блоком

Произойдет ветвление, которое будет автоматически разрешено, когда остальная сеть уйдет вперед в процессе генерации новых блоков.

### Неполная база [blockchain][] в узле

Случай, когда локальная база данных узла "догоняет" базу данных сети.

При этом алгоритм не может работать в силу того, что отсутствуют значения:

* **HB<sub>r-1</sub>** - хеш последнего созданного блока
* **Q<sub>r-1</sub>** - случайное значение последнего раунда работы алгоритма

Требуется определить момент, когда локальная база "догонит" базу данных сети и запустить раунд алгоритма.

### Отсутствие активных исполнителей на шаге

Набор исполнителей вычисляет с помощью [VRF][] и не зависит реального наличия исполнителей в сети.
Может возникнуть ситуация, когда для какого-то шага алгоритма нет активных исполнителей.

### Разрешение ветвлений

На основе [algorand-v9][] (9. Handling Forks, page 70)

[blockchain]: https://ru.wikipedia.org/wiki/Блокчейн
[echo-wp]: https://drive.google.com/file/d/1JBCYt4QKBVK59MWstI0mIJkFUAc9Dy9O
[algorand-v9]: https://drive.google.com/file/d/1dohyg2LMNxHFzzTc5VpUwm_qjegBPKe2
[echo-model]: https://drive.google.com/file/d/1-yLdXbp16jeZJM2JNTbxFPDGU_BaFpOu
[EdDSA]: https://en.wikipedia.org/wiki/EdDSA
[SHA-256]: https://en.wikipedia.org/wiki/SHA-2
[byzantine]: https://ru.wikipedia.org/wiki/Задача_византийских_генералов
[VRF]: https://en.wikipedia.org/wiki/Verifiable_random_function
