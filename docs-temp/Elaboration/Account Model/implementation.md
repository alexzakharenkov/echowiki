# Реализация перехода к выпуску блоков аккаунтами

## Общие проблемы

1. Замена алгоритма подписи транзакций с `ECDSA` на `ed25519`(замена ключей в `authority` аккаунтов).

2. Подпись транзакции регистрации аккаунта. Считаем, что в `authority` уже имеем `ed215519` ключи. Остается проблема - мы не можем использовать `authority` аккаунта в `echorand`, т.к. там может не содержаться ключей вообще(передача прав через `id`, `address`), так и соджержаться `N` ключей не имеющих полного доступа(аля `multisig`). Соответственно необходимо разделение по ключам аккаунта(отдельный ключ для регистрации аккаунтов и использования в `echorand`)

3. Вненсение изменений, затрагивающих `graphene`. Удалять то, что нам не нужно, пишем по месту. Сразу же исправляем и дописываем тесты. (Относится, по большей части, к разделу `изменения распределения комиссии`)

## Авторизация аккаунта на ноде

Так как в `echorand` используются `ed25519` ключи - необходимо добавить поле `eddsa::public_key_t ed_key` в `account_object`, которое будет содержать публичный `ed25519` ключ. Использоваться последний будет только в `echorand`, для разграничения ролей ключей. Также необходимо добавить это поле в `account_update_operation`, для возможности его изменения. Авторизация аккаунта на ноде реализуется с помощью параметров конфига\командной строки. Для этого необходимо добавить как пару ключей, так и `id\name` аккаунта. Как пример - реализация `ed-private-key`. После этого ключи будут доступны всем плагинам, в том числе плагину для регистрации аккаунта, описанному ниже.

## Делегировать права продюсера или верифаера

Для делегирования прав участия в выпуске блоков необходимо поле `account_id_type delegating_account` в структуре `account_options`(см. `voting_account`). В структуре `verifier_t` - добавить публичный и приватный(при наличии в конфигах) ключи аккаунта(`[_delegated_pubkey, _delegated_privkey]`), которому делегированы права верифаера в виде опциональных полей(optional: `_privkey` сделать так же `optional`, убрать `_local`).

Соответствующим образом переделать верификацию сообщений и функтор получения верифаеров: проверять и подписывать с помощью "основного ключа", при неудаче или его отсутствии - с помощью делегированного. Необходимо учитывать, что сообщение, которое было подписано самим аккаунтом - приоритетнее сообщения аккаунта, которому был делегирован выпуск блока. Поэтому при верификации сообщения нужно проверять наличие такого же сообщения(от этого верифаера(продьюсера) на этом раунде и степе) и сохранять более приоритетное(подписанное ключом выбранного аккаунта, а не делегированного).

## Изменение распределения комиссии

Для того, чтобы переводить всю комиссию аккаунту, выпустившему блок необходимо:

1. В методе `generic_evaluator::pay_fee` необходимо пересчитаную и уже подготовленную комиссию `core_fee_paid` зачислять на баланс аккаунта, выпустившего блок.

2. Для того, чтобы получить данные о создателе блока - необходимо добавить его в `node_property_object` по принципу `skip_flags`, добавить метод-аналог `with_skip_flags` и обернуть в него `for`, в котором применяются транзакции в методе `database::_apply_block`.

3. Убрать логику обработки через `FBA`(ее ранее не использовали вообще, и вряд ли будем в `echo`) - убрать метод `generic_evaluator::pay_fba_fee`, удалить `override'ы` в `evaluator'ах`.

Если решим другим образом распределять комиссию - необходимо просто добавить данные в `node_property_object` из пункта 2, при этом будем иметь доступ к ним в `generic_evaluator::pay_fee`

## Реализовать метод регистрации аккаунта на ноде

Необходимо создать новый плагин `registration_plugin`. Работа с последним будет вестись через новый апи `registration_api`, который будет являться прослойкой для работы с плагином, т.к. `api` создается на каждое подключение. В `registration_api` передается ссылка на `application`, внутри api мы сможем получить плагин, в котором в качестве публичного метода будет доступен метод регистрации.

Таким образом вся логика выносится в отдельный модуль, который будет иметь доступ к ключам, `db`, `p2p` с "торчащим" наружу методом регистрации, вызываемым из `api`. При необходимости - просто дорабатывается(можно будет реализовать сбор статистики, например), отключается и т.п.

Место "стыковки" - `api.cpp`, метод `login_api::enable_api`, в котором имеет доступ к инстансу `application` и, соответственно, плагинам(см. `debug_api`).
